# 13-14 par
13
ВОПРОС:1. Объясните значения слов «поле», «запись»
Поле – это элемент структуры данных, который содержит одно значение определенного типа. Например, в базе данных поле может хранить фамилию человека, его возраст или дату рождения.

Запись – это совокупность полей, представляющая собой одну единицу информации. Записи обычно соответствуют строкам в таблицах баз данных. Каждая запись включает все поля, описывающие объект или сущность, например, информацию об одном человеке, товаре или заказе.

ВОПРОС:2. Зачем каждому полю присваивают свой тип?
Каждому полю присваивается определенный тип данных для того, чтобы система могла корректно обрабатывать информацию. Тип данных определяет, какого рода информация будет храниться в этом поле (числовая, текстовая, дата и время и т.д.), а также позволяет системе оптимизировать хранение и обработку данных. Это важно для обеспечения правильности вычислений, сортировки, сравнения значений и других операций.

ВОПРОС:3. Какие типы данных поддерживаются в современных СУБД?
Современные системы управления базами данных поддерживают множество типов данных, среди которых наиболее распространенные:

Числовые: целые числа (INTEGER), вещественные числа (FLOAT, DOUBLE), денежные значения (DECIMAL).
Текстовые: строки фиксированной длины (CHAR), строки переменной длины (VARCHAR), большие текстовые блоки (TEXT).
Дата и время: даты (DATE), время (TIME), временные метки (TIMESTAMP).
Логические: булевы значения (BOOLEAN).
Бинарные: массивы байтов (BLOB).
Специальные типы: уникальные идентификаторы (UUID), JSON, XML и другие.

ВОПРОС:4. Что такое ключ таблицы? Назовите и объясните два свойства ключа
Ключ таблицы – это одно или несколько полей, которые однозначно определяют каждую запись в таблице. Ключ используется для уникальной идентификации записей и предотвращения дублирования данных.
Два основных свойства ключа:
Уникальность. Значения ключей должны быть уникальными для каждой записи. Это свойство гарантирует отсутствие повторяющихся записей.
Неизменность. После создания записи значения ключевых полей не должны изменяться, так как они используются для однозначного определения этой записи.

ВОПРОС:5. Чем отличаются простой и составной ключи?
Простой ключ состоит только из одного поля. Например, уникальный идентификационный номер товара является простым ключом.

Составной ключ состоит из двух или более полей. Он используется тогда, когда ни одно отдельное поле не может обеспечить уникальность записи. Пример составного ключа: комбинация фамилии и имени сотрудника, если возможно наличие сотрудников с одинаковыми именами и фамилиями.

ВОПРОС:6. Чем отличаются понятия «ключ» и «первичный ключ»?
Ключи (или потенциальные ключи) – это любые комбинации полей, которые могут использоваться для уникальной идентификации записей в таблице. Они удовлетворяют требованиям уникальности и неизменности.

Первичный ключ – это конкретный выбранный ключ, который используется системой для организации хранения и доступа к данным. Обычно выбирается тот ключ, который наиболее удобен для работы с данными. Первичных ключей в таблице может быть только один.

ВОПРОС:7. Какие из следующих данных могут быть ключом, а какие не могут:
Фамилия – не может быть ключом, так как фамилии часто повторяются.
Имя – аналогично фамилии, имена часто встречаются у разных людей.
Номер читательского билета – может быть ключом, если номера уникальны и неизменны.
Адрес электронной почты – может быть ключом при условии, что адреса являются уникальными и неизменными.
Адрес веб-сайта – может быть ключом, если каждый сайт имеет уникальный URL.
Марка автомобиля – не может быть ключом, поскольку марки автомобилей повторяются.
8. Объясните, когда одни и те же данные одной ситуации могут быть ключом, а в другой - нет (например, адрес электронной почты, марка стиральной машины и т.п.). Приведите примеры
Одни и те же данные могут служить ключом в одних ситуациях и не подходить для этого в других, в зависимости от контекста использования.

Примеры:

Адрес электронной почты. В системе регистрации пользователей он может быть уникальным ключом, так как предполагается, что пользователи регистрируются под разными email-адресами. Однако в системе учета почтовых рассылок email может не быть ключом, потому что одному человеку может приходить много писем.
Марка стиральной машины. В каталоге товаров она не может быть ключом, так как существует множество стиральных машин одной марки. Но в учетной системе ремонта бытовой техники марка вместе с серийным номером может стать частью составного ключа, обеспечивающего уникальность каждой единицы оборудования.

ВОПРОС:9. В каких случаях в качестве первичного ключа используют номер записи? Можно ли применять такой подход, если в таблице есть другое уникальное поле?
В качестве первичного ключа часто используют суррогатный ключ, то есть искусственно созданный уникальный идентификатор, например, автоинкрементное числовое поле. Такой подход применяется, когда:

Нет очевидного естественного кандидата на роль первичного ключа.
Поле-кандидат на роль ключа слишком длинное или сложное для обработки.
Необходимо упростить работу с внешними связями между таблицами.
Если в таблице уже есть другое уникальное поле, можно использовать его в качестве первичного ключа, но иногда удобнее оставить его как альтернативный ключ и создать отдельный суррогатный ключ для упрощения работы с базой данных.

ВОПРОС:10. Какие методы поиска данных вы знаете?
Основные методы поиска данных включают:

Линейный поиск – последовательная проверка всех элементов массива до нахождения нужного элемента.
Двоичный поиск – метод деления пополам, применяемый к отсортированным данным.
Поиск по хеш-таблице – быстрый доступ к элементу через использование функции хэширования.
Интерполяционный поиск – модификация бинарного поиска, учитывающая распределение данных.
Поиск в деревьях – поиск в структурах данных, таких как бинарные деревья поиска.
ВОПРОС:11. Чем различаются линейный и двоичный поиск? Назовите их достоинства и недостатки
Линейный поиск:

Достоинства: Простота реализации, подходит для любых наборов данных.
Недостатки: Низкая эффективность на больших объемах данных (сложность 
O
(
n
)
O(n)).
Двоичный поиск:

Достоинства: Высокая скорость поиска (логарифмическая сложность 
O
(
log
⁡
n
)
O(logn)), эффективен для больших объемов данных.
Недостатки: Требует предварительной сортировки данных, что может занять дополнительное время.

ВОПРОС:12. Что такое индекс? Как он строится?
Индекс – это дополнительная структура данных, которая ускоряет поиск и сортировку записей в таблице базы данных. Индекс создается для одного или нескольких полей и содержит ссылки на соответствующие записи в основной таблице.
Индекс строится путем создания упорядоченного списка значений указанных полей с указателями на соответствующие записи. Основные типы индексов:
B-дерево – широко используемая структура для индексов, позволяющая быстро находить нужные элементы.
Хэш-индексы – подходят для поиска по точному совпадению значений.

ВОПРОС:13. Можно ли для одной и той же таблицы построить несколько индексов?
Да, для одной таблицы можно построить несколько индексов. Это особенно полезно, если таблица участвует в различных запросах, требующих быстрого поиска по разным полям. Например, можно создать отдельные индексы для полей, используемых в условиях WHERE, JOIN и ORDER BY.

ВОПРОС:14. Объясните принцип поиска с помощью индекса
При поиске с использованием индекса система сначала обращается к индексу, где находит нужное значение и соответствующий указатель на запись в основной таблице. Таким образом, вместо полного перебора всей таблицы происходит прямой переход к нужной записи, что значительно сокращает время поиска.

**ВОПРОС:15. Что такое целостность базы данных? Какие виды целостности вы знаете?
Целостность базы данных – это свойство, которое обеспечивает правильность и непротиворечивость хранимых данных. Существуют различные виды целостности:
Сущностная целостность – требует наличия уникальных идентификаторов для каждой записи (первичные ключи).
Ссылочная целостность – предполагает, что внешние ключи ссылаются на существующие записи в связанных таблицах.
Доменная целостность – подразумевает соблюдение ограничений на допустимые значения полей (типы данных, диапазоны значений и т.д.).**

**ВОПРОС:16. Как обеспечивается физическая целостность данных?
Физическая целостность данных поддерживается за счет механизмов защиты данных на уровне хранения и передачи. Примеры:
Использование RAID-массивов для резервирования данных.
Применение контрольных сумм и кодов коррекции ошибок для обнаружения повреждений данных.
Резервное копирование и восстановление данных.**

**ВОПРОС:17. Как обеспечивается логическая целостность данных?
Логическая целостность данных обеспечивается соблюдением правил бизнес-логики и ограничений, установленных разработчиками базы данных. Методы поддержания логической целостности:
Ограничения на уровне базы данных (ограничение UNIQUE, NOT NULL, CHECK и др.).
Тригеры, выполняющие проверки и действия перед вставкой, обновлением или удалением данных.
Программные проверки на стороне приложения.**


Задача 1
Необходимо оценить количество сравнений, которое придется сделать при использовании линейного и двоичного поиска по одному из полей в базе данных, содержащей 
N
**=
2
20
N=2 
20**
 **записей.**

**Линейный поиск**
**Для линейного поиска необходимо проверить каждое значение в худшем случае, пока не найдем нужный элемент. Поэтому максимальное количество сравнений равно количеству записей в базе данных:**

**$$ N_{\text{линейный}} = 2^{20}**

**$$**

**Двоичный поиск
Двоичный поиск использует метод деления пополам, поэтому количество сравнений определяется как 
log**
⁡
**2
(
N
)
log 
2**
​
**(N). Поскольку база данных содержит 
2
20
2 
20
  записей, то:**

$$ N_{\text{двоичный}} = \log_2(2^{20}) = 20

$$

**Сравнение скорости
Теперь оценим, во сколько раз быстрее работает двоичный поиск по сравнению с линейным:**

**$$ \frac{N_{\text{линейный}}}{N_{\text{двоичный}}} = \frac{2^{20}}{20} \approx 524288**

**$$**

**Таким образом, двоичный поиск примерно в 524 288 раз быстрее, чем линейный.**

**Задача 2**
**Таблица содержит следующие поля: Дата, Номер заказа, Товар и Количество. Нужно определить возможные варианты выбора первичного ключа и предложить индексы.**

**Выбор первичного ключа
Поскольку первичный ключ должен быть уникальным и неизменяемым, мы можем рассмотреть следующие варианты:**

**Номер заказа – если номера заказов уникальны и никогда не меняются, этот вариант подойдет для первичного ключа.
Комбинация полей "Дата" + "Номер заказа" – если существует вероятность, что номера заказов могут повторяться в разные дни, такая комбинация обеспечит уникальность.
Автоинкрементное поле – можно добавить специальное поле (например, ID), которое автоматически увеличивается при добавлении новой записи. Это самый универсальный способ.
Индексы
Индексы стоит строить для тех полей, по которым чаще всего выполняются запросы. Возможные варианты:**

**Индекс по полю "Товар" – если часто выполняется фильтрация по конкретным товарам.
Индекс по полю "Количество" – если нужно выполнять агрегации или сортировать заказы по количеству проданных товаров.
Индекс по полю "Дата" – если требуется искать заказы за определенные периоды времени.
Составной индекс по полям "Дата" + "Номер заказа" – если такие комбинации часто участвуют в запросах.**

**Задача 3**
**В таблице школьной базы данных содержатся следующие поля: Фамилия, Имя, Отчество, Дата рождения, Год выпуска, Номер паспорта, Номер аттестата. Необходимо выбрать первичный ключ.**

**Выбор первичного ключа**
**В данной задаче мы имеем дело с несколькими возможными кандидатами на роль первичного ключа:**

**Номер аттестата – вероятно, самое подходящее поле, так как оно должно быть уникальным для каждого ученика и неизменным.
Номер паспорта – тоже может быть уникальным, однако паспорт может быть заменен, что нарушает требование неизменности.
Комбинация полей "Фамилия", "Имя", "Отчество", "Дата рождения" – хотя такие комбинации могут быть уникальными, они сложны для обработки и могут изменяться (например, смена фамилии).
Исходя из этих соображений, наилучшим выбором будет номер аттестата как первичный ключ, так как он гарантированно уникален и неизменен.**

**Многотабличные базы данных
В многотабличных базах данных важно учитывать связи между таблицами и поддерживать ссылочную целостность. Для этого используются внешние ключи (foreign keys). Рассмотрим пример многотабличной базы данных для школы:**

**1-Таблица учеников:
ID (первичный ключ)
Фамилия
Имя
Отчество
Дата рождения
Класс (внешний ключ на таблицу классов)
2-Таблица классов:
ID (первичный ключ)
Название класса
Учитель (внешний ключ на таблицу учителей)
3-Таблица учителей:
ID (первичный ключ)
Фамилия
Имя
Отчество
Предмет
4-Таблица предметов:
ID (первичный ключ)
Название предмета
Такая структура позволяет легко отслеживать связь между учениками, классами и учителями, обеспечивая целостность данных.**

&14
**ВОПРОС:1. Почему собирать все данные в одной таблице во многих случаях невыгодно?
Сбор всех данных в одной таблице приводит к ряду проблем:
Избыточность данных. При наличии большого количества однотипных записей возникает необходимость многократного повторения одних и тех же данных, что увеличивает размер базы данных и усложняет её поддержку.
Нарушение принципов нормализации. Нормализация данных помогает избежать избыточности и аномалий обновления/удаления, что делает структуру базы данных более гибкой и устойчивой к изменениям.
Трудности с управлением целостностью данных. Если все данные находятся в одной таблице, сложнее контролировать уникальность и согласованность данных, особенно при большом количестве взаимосвязанных сущностей.
Производительность. Поиск и обработка данных в большой таблице занимают больше времени, чем в нескольких специализированных таблицах с правильно настроенными индексами.**

**ВОПРОС:2. По какому принципу данные разбиваются на несколько таблиц?
Данные разбиваются на несколько таблиц по следующим принципам:
Принцип нормализации. Данные разделяются таким образом, чтобы каждая таблица содержала информацию о конкретной сущности или группе взаимосвязанных атрибутов. Например, информация о студентах хранится отдельно от информации о курсах, которые они посещают.
Минимизация избыточности. Разделение данных на несколько таблиц позволяет избегать повторного ввода одних и тех же данных, что уменьшает риск возникновения противоречий и упрощает обновление информации.
Обеспечение целостности данных. Разбиение данных на таблицы помогает легче управлять уникальностью и ссылочной целостностью, предотвращать потерю данных при удалении и обновлении.**

**ВОПРОС:3. Что такое внешний ключ таблицы?
Внешний ключ (foreign key) — это поле или группа полей в одной таблице, которые ссылаются на первичный ключ другой таблицы. Внешние ключи обеспечивают связь между таблицами и помогают поддерживать ссылочную целостность данных.
Пример: В таблице "Заказы" поле "Клиент_ID" может быть внешним ключом, ссылающимся на поле "ID" в таблице "Клиенты".**

**ВОПРОС:4. Что такое ссылочная целостность БД? Как она обеспечивается?
Ссылочная целостность (referential integrity) — это гарантия того, что все внешние ключи в таблицах ссылаются на существующие записи в связанных таблицах. Она предотвращает появление "висячих ссылок" — ситуаций, когда внешний ключ ссылается на несуществующую запись.
Ссылочная целостность обеспечивается следующими мерами:
Ограничения внешних ключей. В базе данных создаются ограничения, которые проверяют существование соответствующих записей в связанной таблице при вставке, обновлении или удалении данных.
Тригеры. Специальные процедуры, которые автоматически выполняют необходимые действия при изменении данных (например, каскадное удаление или обновление связанных записей).
Программные проверки. В некоторых случаях логика контроля ссылочной целостности реализуется на уровне приложений, работающих с базой данных.**

**ВОПРОС:5. Какие типы связей используются в многотабличных базах данных?
В многотабличных базах данных используются следующие типы связей:
«Один к одному» (1:1). Одна запись в первой таблице соответствует ровно одной записи во второй таблице. Например, одна запись о сотруднике может соответствовать одной записи о его контактной информации.
«Один ко многим» (1:M). Одна запись в первой таблице может соответствовать нескольким записям во второй таблице. Например, один клиент может иметь несколько заказов.
«Многие ко многим» (M:N). Несколько записей в первой таблице могут соответствовать нескольким записям во второй таблице. Такая связь обычно реализуется через промежуточную таблицу, содержащую внешние ключи обеих таблиц. Например, студенты могут посещать несколько 
курсов, и курсы могут посещаться несколькими студентами.**

**ВОПРОС:6. Когда применяется связь «1:1»? Какие поля при этом связываются?
Связь «один к одному» (1:1) применяется, когда две сущности имеют взаимно-однозначное соответствие. То есть каждая запись в одной таблице соответствует ровно одной записи в другой таблице.
Пример:
У каждого сотрудника может быть только один уникальный номер социального страхования (ИНН), и наоборот, каждый ИНН принадлежит только одному сотруднику.
Поля, участвующие в такой связи, обычно содержат уникальные идентификаторы, которые служат первичными ключами в своих таблицах.**

**ВОПРОС:7. Когда применяется связь «1:M»? Какие поля при этом связываются?
Связь «один ко многим» (1:M) применяется, когда одна запись в первой таблице может соответствовать нескольким записям во второй таблице.
Пример:
Один клиент может разместить несколько заказов.
В такой связи поле внешнего ключа в таблице "Множество" (например, "Заказ") ссылается на поле первичного ключа в таблице "Один" (например, "Клиент").**

**ВОПРОС:8. Таблицы A и B связаны через свои ключевые поля. Что это за связь?
Это связь типа «один к одному» (1:1), так как каждая запись в таблице A связана с единственной записью в таблице B, и наоборот. Ключевые поля обеих таблиц используются для установления связи.**

**ВОПРОС:9. Связь между таблицами A и B установлена через ключевое поле таблицы B и неключевое поле таблицы A. Что это за связь?
Это связь типа «один ко многим» (1:M). Ключевое поле таблицы B (например, первичный ключ) служит внешним ключом в таблице A, позволяя одной записи в таблице B соответствовать нескольким записям в таблице A.**

**ВОПРОС:10. Между таблицами A и B по смыслу существует связь «многие ко многим». Как добиться этого в СУБД, которая такую связь не поддерживает?
Чтобы реализовать связь «многие ко многим» (M:N) в СУБД, которая напрямую не поддерживает эту связь, используется промежуточная таблица (связующая таблица):
Создается новая таблица, содержащая внешние ключи обоих исходных таблиц.
Эта таблица связывает записи из таблиц A и B, позволяя каждой записи из A соответствовать нескольким записям из B, и наоборот.
Пример:
Таблица A: Студенты
Таблица B: Курсы
Промежуточная таблица: Регистрация (Student_ID, Course_ID)**

**ВОПРОС:11. Подумайте, какие изменения можно внести в базу данных, описанную в конце параграфа, если клиенты часто заказывают несколько одинаковых блюд.
Предположим, что текущая структура базы данных выглядит следующим образом:
Таблица "Заказы": Заказ_ID, Клиент_ID, Дата, Сумма
Таблица "Блюда": Блюдо_ID, Название, Цена
Таблица "Состав заказа": Заказ_ID, Блюдо_ID, Количество
Изменения, которые можно внести:
Добавление поля "Количество" в таблицу "Состав заказа". Это позволит указать, сколько порций конкретного блюда было заказано.
Новая структура таблицы "Состав заказа":
Состав заказа: Заказ_ID, Блюдо_ID, Количество
Обновление бизнес-логики приложения для поддержки возможности добавления нескольких одинаковых блюд в один заказ.
Эти изменения позволят более эффективно управлять заказами клиентов, включая возможность заказа нескольких порций одного и того же блюда.**

**ЗАДАЧИ**
**Задача 1
Фирма ведёт базу данных заказчиков, состоящую из двух связанных таблиц:**


-- Таблица 'Заказчики'
Код | Название      | Код города
----|---------------|-----------
1   | Иванов Т.М.   | 3
2   | Пановко И.Т.  | 2
3   | Черненко И.А. | 3
4   | Пановко А.И.  | 2
5   | Иванова А.И.  | 1

-- Таблица 'Города'
Код | Название
----|------------
1   | Москва
2   | Санкт-Петербург
3   | Пермь
Вопрос: Сколько заказчиков располагается в Перми?

**Решение:
Для ответа на вопрос нам нужно найти строки в таблице 'Заказчики', где 'Код города' равен 3 (код Перми), и посчитать количество таких строк.**


**SELECT COUNT(*)
FROM Заказчики
WHERE Код города = 3;
Ответ: 2 заказчика располагаются в Перми.**

**Задача 2
Добавленные таблицы:**


-- Таблица 'Заказы'
Код заказчика | Артикул | Количество упаковок
--------------|---------|---------------------
1011          | 7576    | 10
1012          | 7576    | 20
1013          | 3889    | 25
1014          | 7825    | 30
1015          | 7576    | 10

-- Таблица 'Товары'
Артикул | Название     | Цена за упаковку
--------|--------------|------------------
7576    | Бумага       | 150 руб.
2325    | Карандаши    | 200 руб.
3889    | Фломастеры   | 350 руб.
2987    | Дневники     | 400 руб.
7825    | Пеналы       | 250 руб.
**Вопросы:**

**a) Какие товары отправлены в каждый из городов? b) Сколько бумаги отправлено в каждый из городов? c) Какова общая стоимость товаров, отправленных в каждый из городов?
Решения:
a) Чтобы узнать, какие товары отправлены в каждый город, нужно объединить таблицы 'Заказчики', 'Заказы' и 'Товары'.**


**SELECT Города.Название AS Город, Товары.Название AS Товар
FROM Заказы
JOIN Заказчики ON Заказы.Код заказчика = Заказчики.Код
JOIN Города ON Заказчики.Код города = Города.Код
JOIN Товары ON Заказы.Артикул = Товары.Артикул;
Результат:**

**Город	Товар
Пермь	Бумага
Липецк	Бумага
Воронеж	Фломастеры
Москва	Пеналы
Пермь	Бумага
b) Чтобы узнать, сколько бумаги отправлено в каждый город, нужно выбрать только те строки, где товаром является бумага ('Бумага'), и просуммировать количество упаковок для каждого города.**


**SELECT Города.Название AS Город, SUM(Заказы.Количество упаковок) AS Количество бумаги
FROM Заказы
JOIN Заказчики ON Заказы.Код заказчика = Заказчики.Код
JOIN Города ON Заказчики.Код города = Города.Код
JOIN Товары ON Заказы.Артикул = Товары.Артикул
WHERE Товары.Название = 'Бумага'
GROUP BY Города.Название;
Результат:

Город	Количество бумаги
Пермь	20
Липецк	20
c) Чтобы узнать общую стоимость товаров, отправленных в каждый город, нужно умножить количество упаковок на цену упаковки и просуммировать результаты для каждого города.**


**SELECT Города.Название AS Город, SUM(Заказы.Количество упаковок * Товары.Цена за упаковку) AS Общая стоимость
FROM Заказы
JOIN Заказчики ON Заказы.Код заказчика = Заказчики.Код
JOIN Города ON Заказчики.Код города = Города.Код
JOIN Товары ON Заказы.Артикул = Товары.Артикул
GROUP BY Города.Название;
Результат:**

**Город	Общая стоимость
Пермь	3000 руб.
Липецк	3000 руб.
Воронеж	8750 руб.
Москва	7500 руб.**

**Задача 3**
**Фрагмент базы данных о родственных отношениях:**


**Родственные отношения**
**------------------------------------
**| ФИО         | Родственное лицо   |**
------------------------------------
| Иванов И.И. | Иванов А.И.        |
| Петров П.П. | Петрова М.П.       |
| Сидоров С.С.| Сидорова Е.С.      |
| Васильев В.В| Васильева О.В.     |
**------------------------------------**
**Вопрос: Определите на основании приведённых данных фамилию и инициалы.**

**Решение:**

**Так как в таблице указаны только ФИО родственников без указания конкретных отношений (например, брат, сестра, мать и т.д.), невозможно точно определить, кто кому приходится родственником. Однако можно предположить, что указанные в столбце 'ФИО' люди являются родителями или супругами тех, кто указан в столбце 'Родственное лицо'. Например:**

**Иванов И.И. может быть отцом Иванова А.И.
Петров П.П. может быть мужем Петровой М.П.
Сидоров С.С. может быть братом Сидоровой Е.С.
Васильев В.В может быть мужем Васильевой О.В.
Без дополнительной информации нельзя точно сказать, кем именно являются друг другу указанные лица.**
